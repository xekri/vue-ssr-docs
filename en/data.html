
<!DOCTYPE HTML>
<html lang="en" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Data Pre-fetching and State Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-theme-vuejs/vue.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="hydration.html" />
    
    
    <link rel="prev" href="routing.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="basic.html">
            
                <a href="basic.html">
            
                    
                    Basic Usage
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="universal.html">
            
                <a href="universal.html">
            
                    
                    Writing Universal Code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="structure.html">
            
                <a href="structure.html">
            
                    
                    Source Code Structure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="routing.html">
            
                <a href="routing.html">
            
                    
                    Routing and Code-Splitting
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.6" data-path="data.html">
            
                <a href="data.html">
            
                    
                    Data Pre-fetching and State
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="hydration.html">
            
                <a href="hydration.html">
            
                    
                    Client Side Hydration
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="bundle-renderer.html">
            
                <a href="bundle-renderer.html">
            
                    
                    Introducing Bundle Renderer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="build-config.html">
            
                <a href="build-config.html">
            
                    
                    Build Configuration
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="css.html">
            
                <a href="css.html">
            
                    
                    CSS Management
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="head.html">
            
                <a href="head.html">
            
                    
                    Head Management
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="caching.html">
            
                <a href="caching.html">
            
                    
                    Caching
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="streaming.html">
            
                <a href="streaming.html">
            
                    
                    Streaming
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="api.html">
            
                <a href="api.html">
            
                    
                    API Reference
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.1" data-path="api.html">
            
                <a href="api.html#createrendereroptions">
            
                    
                    createRenderer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.2" data-path="api.html">
            
                <a href="api.html#createbundlerendererbundle-options">
            
                    
                    createBundleRenderer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.3" data-path="api.html">
            
                <a href="api.html#class-renderer">
            
                    
                    Class: Renderer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.4" data-path="api.html">
            
                <a href="api.html#class-bundlerenderer">
            
                    
                    Class: BundleRenderer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.5" data-path="api.html">
            
                <a href="api.html#renderer-options">
            
                    
                    Renderer Options
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.14.5.1" data-path="api.html">
            
                <a href="api.html#template">
            
                    
                    template
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.5.2" data-path="api.html">
            
                <a href="api.html#clientmanifest">
            
                    
                    clientManifest
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.5.3" data-path="api.html">
            
                <a href="api.html#inject">
            
                    
                    inject
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.5.4" data-path="api.html">
            
                <a href="api.html#shouldpreload">
            
                    
                    shouldPreload
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.5.5" data-path="api.html">
            
                <a href="api.html#runinnewcontext">
            
                    
                    runInNewContext
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.5.6" data-path="api.html">
            
                <a href="api.html#basedir">
            
                    
                    basedir
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.5.7" data-path="api.html">
            
                <a href="api.html#cache">
            
                    
                    cache
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14.5.8" data-path="api.html">
            
                <a href="api.html#directives">
            
                    
                    directives
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.14.6" data-path="api.html">
            
                <a href="api.html#webpack-plugins">
            
                    
                    webpack Plugins
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Data Pre-fetching and State</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="data-pre-fetching-and-state">Data Pre-Fetching and State</h1>
<h2 id="data-store">Data Store</h2>
<p>During SSR, we are essentially rendering a &quot;snapshot&quot; of our app, so if the app relies on some asynchronous data, <strong>these data need to be pre-fetched and resolved before we start the rendering process</strong>.</p>
<p>Another concern is that on the client, the same data needs to be available before we mount the client side app - otherwise the client app would render using different state and the hydration would fail.</p>
<p>To address this, the fetched data needs to live outside the view components, in a dedicated data store, or a &quot;state container&quot;. On the server, we can pre-fetch and fill data into the store before rendering. In addition, we will serialize and inline the state in the HTML. The client-side store can directly pick up the inlined state before we mount the app.</p>
<p>We will be using the official state management library <a href="https://github.com/vuejs/vuex/" target="_blank">Vuex</a> for this purpose. Let&apos;s create a <code>store.js</code> file, with some mocked logic for fetching an item based on an id:</p>
<pre><code class="lang-js"><span class="hljs-comment">// store.js</span>
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;vue&apos;</span>
<span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;vuex&apos;</span>

Vue.use(Vuex)

<span class="hljs-comment">// Assume we have a universal API that returns Promises</span>
<span class="hljs-comment">// and ignore the implementation details</span>
<span class="hljs-keyword">import</span> { fetchItem } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./api&apos;</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStore</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vuex.Store({
    state: {
      items: {}
    },
    actions: {
      fetchItem ({ commit }, id) {
        <span class="hljs-comment">// return the Promise via `store.dispatch()` so that we know</span>
        <span class="hljs-comment">// when the data has been fetched</span>
        <span class="hljs-keyword">return</span> fetchItem(id).then(item =&gt; {
          commit(<span class="hljs-string">&apos;setItem&apos;</span>, { id, item })
        })
      }
    },
    mutations: {
      setItem (state, { id, item }) {
        Vue.set(state.items, id, item)
      }
    }
  })
}
</code></pre>
<p>And update <code>app.js</code>:</p>
<pre><code class="lang-js"><span class="hljs-comment">// app.js</span>
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;vue&apos;</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./App.vue&apos;</span>
<span class="hljs-keyword">import</span> { createRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./router&apos;</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./store&apos;</span>
<span class="hljs-keyword">import</span> { sync } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;vuex-router-sync&apos;</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createApp</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// create router and store instances</span>
  <span class="hljs-keyword">const</span> router = createRouter()
  <span class="hljs-keyword">const</span> store = createStore()

  <span class="hljs-comment">// sync so that route state is available as part of the store</span>
  sync(store, router)

  <span class="hljs-comment">// create the app instance, injecting both the router and the store</span>
  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue({
    router,
    store,
    render: h =&gt; h(App)
  })

  <span class="hljs-comment">// expose the app, the router and the store.</span>
  <span class="hljs-keyword">return</span> { app, router, store }
}
</code></pre>
<h2 id="logic-collocation-with-components">Logic Collocation with Components</h2>
<p>So, where do we place the code that dispatches the data-fetching actions?</p>
<p>The data we need to fetch is determined by the route visited - which also determines what components are rendered. In fact, the data needed for a given route is also the data needed by the components rendered at that route. So it would be natural to place the data fetching logic inside route components.</p>
<p>We will expose a custom static function <code>asyncData</code> on our route components. Note because this function will be called before the components are instantiated, it doesn&apos;t have access to <code>this</code>. The store and route information needs to be passed in as arguments:</p>
<pre><code class="lang-html"><span class="hljs-comment">&lt;!-- Item.vue --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ item.title }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  asyncData ({ store, route }) {
    <span class="hljs-comment">// return the Promise from the action</span>
    <span class="hljs-keyword">return</span> store.dispatch(<span class="hljs-string">&apos;fetchItem&apos;</span>, route.params.id)
  },

  computed: {
    <span class="hljs-comment">// display the item from store state.</span>
    item () {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$store.state.items[<span class="hljs-keyword">this</span>.$route.params.id]
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h2 id="server-data-fetching">Server Data Fetching</h2>
<p>In <code>entry-server.js</code> we can get the components matched by a route with <code>router.getMatchedComponents()</code>, and call <code>asyncData</code> if the component exposes it. Then we need to attach resolved state to the render context.</p>
<pre><code class="lang-js"><span class="hljs-comment">// entry-server.js</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./app&apos;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> context =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
    <span class="hljs-keyword">const</span> { app, router, store } = createApp()

    router.push(context.url)

    router.onReady(() =&gt; {
      <span class="hljs-keyword">const</span> matchedComponents = router.getMatchedComponents()
      <span class="hljs-keyword">if</span> (!matchedComponents.length) {
        <span class="hljs-keyword">return</span> reject({ code: <span class="hljs-number">404</span> })
      }

      <span class="hljs-comment">// call `asyncData()` on all matched route components</span>
      <span class="hljs-built_in">Promise</span>.all(matchedComponents.map(Component =&gt; {
        <span class="hljs-keyword">if</span> (Component.asyncData) {
          <span class="hljs-keyword">return</span> Component.asyncData({
            store,
            route: router.currentRoute
          })
        }
      })).then(() =&gt; {
        <span class="hljs-comment">// After all preFetch hooks are resolved, our store is now</span>
        <span class="hljs-comment">// filled with the state needed to render the app.</span>
        <span class="hljs-comment">// When we attach the state to the context, and the `template` option</span>
        <span class="hljs-comment">// is used for the renderer, the state will automatically be</span>
        <span class="hljs-comment">// serialized and injected into the HTML as `window.__INITIAL_STATE__`.</span>
        context.state = store.state

        resolve(app)
      }).catch(reject)
    }, reject)
  })
}
</code></pre>
<p>When using <code>template</code>, <code>context.state</code> will automatically be embedded in the final HTML as <code>window.__INITIAL_STATE__</code> state. On the client, the store should pick up the state before mounting the application:</p>
<pre><code class="lang-js"><span class="hljs-comment">// entry-client.js</span>

<span class="hljs-keyword">const</span> { app, router, store } = createApp()

<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.__INITIAL_STATE__) {
  store.replaceState(<span class="hljs-built_in">window</span>.__INITIAL_STATE__)
}
</code></pre>
<h2 id="client-data-fetching">Client Data Fetching</h2>
<p>On the client, there are two different approaches for handling data fetching:</p>
<ol>
<li><p><strong>Resolve data before route navigation:</strong></p>
<p>With this strategy, the app will stay on the current view until the data needed by the incoming view has been resolved. The benefit is that the incoming view can directly render the full content when it&apos;s ready, but if the data fetching takes a long time, the user will feel &quot;stuck&quot; on the current view. It is therefore recommended to provide a data loading indicator if using this strategy.</p>
<p>We can implement this strategy on the client by checking matched components and invoking their <code>asyncData</code> function inside a global route hook. Note we should register this hook after the initial route is ready so that we don&apos;t unnecessarily fetch the server-fetched data again.</p>
<pre><code class="lang-js"><span class="hljs-comment">// entry-client.js</span>

<span class="hljs-comment">// ...omitting unrelated code</span>

router.onReady(() =&gt; {
 <span class="hljs-comment">// Add router hook for handling asyncData.</span>
 <span class="hljs-comment">// Doing it after initial route is resolved so that we don&apos;t double-fetch</span>
 <span class="hljs-comment">// the data that we already have. Using `router.beforeResolve()` so that all</span>
 <span class="hljs-comment">// async components are resolved.</span>
 router.beforeResolve((to, <span class="hljs-keyword">from</span>, next) =&gt; {
   <span class="hljs-keyword">const</span> matched = router.getMatchedComponents(to)
   <span class="hljs-keyword">const</span> prevMatched = router.getMatchedComponents(<span class="hljs-keyword">from</span>)

   <span class="hljs-comment">// we only care about none-previously-rendered components,</span>
   <span class="hljs-comment">// so we compare them until the two matched lists differ</span>
   <span class="hljs-keyword">let</span> diffed = <span class="hljs-literal">false</span>
   <span class="hljs-keyword">const</span> activated = matched.filter((c, i) =&gt; {
     <span class="hljs-keyword">return</span> diffed || (diffed = (prevMatched[i] !== c))
   })

   <span class="hljs-keyword">if</span> (!activated.length) {
     <span class="hljs-keyword">return</span> next()
   }

   <span class="hljs-comment">// this is where we should trigger a loading indicator if there is one</span>

   <span class="hljs-built_in">Promise</span>.all(activated.map(c =&gt; {
     <span class="hljs-keyword">if</span> (c.asyncData) {
       <span class="hljs-keyword">return</span> c.asyncData({ store, route: to })
     }
   })).then(() =&gt; {

     <span class="hljs-comment">// stop loading indicator</span>

     next()
   }).catch(next)
 })

 app.$mount(<span class="hljs-string">&apos;#app&apos;</span>)
})
</code></pre>
</li>
<li><p><strong>Fetch data after the matched view is rendered:</strong></p>
<p>This strategy places the client-side data-fetching logic in a view component&apos;s <code>beforeMount</code> function. This allows the views to switch instantly when a route navigation is triggered, so the app feels a bit more responsive. However, the incoming view will not have the full data available when it&apos;s rendered. It is therefore necessary to have a conditional loading state for each view component that uses this strategy.</p>
<p>This can be achieved with a client-only global mixin:</p>
<pre><code class="lang-js">Vue.mixin({
 beforeMount () {
   <span class="hljs-keyword">const</span> { asyncData } = <span class="hljs-keyword">this</span>.$options
   <span class="hljs-keyword">if</span> (asyncData) {
     <span class="hljs-comment">// assign the fetch operation to a promise</span>
     <span class="hljs-comment">// so that in components we can do `this.dataPromise.then(...)` to</span>
     <span class="hljs-comment">// perform other tasks after data is ready</span>
     <span class="hljs-keyword">this</span>.dataPromise = asyncData({
       store: <span class="hljs-keyword">this</span>.$store,
       route: <span class="hljs-keyword">this</span>.$route
     })
   }
 }
})
</code></pre>
</li>
</ol>
<p>The two strategies are ultimately different UX decisions and should be picked based on the actual scenario of the app you are building. But regardless of which strategy you pick, the <code>asyncData</code> function should also be called when a route component is reused (same route, but params or query changed. e.g. from <code>user/1</code> to <code>user/2</code>). We can also handle this with a client-only global mixin:</p>
<pre><code class="lang-js">Vue.mixin({
  beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) {
    <span class="hljs-keyword">const</span> { asyncData } = <span class="hljs-keyword">this</span>.$options
    <span class="hljs-keyword">if</span> (asyncData) {
      asyncData({
        store: <span class="hljs-keyword">this</span>.$store,
        route: to
      }).then(next).catch(next)
    } <span class="hljs-keyword">else</span> {
      next()
    }
  }
})
</code></pre>
<h2 id="store-code-splitting">Store Code Splitting</h2>
<p>In a large application, our Vuex store will likely be split into multiple modules. Of course, it is also possible to code-split these modules into corresponding route component chunks. Suppose we have the following store module:</p>
<pre><code class="lang-js"><span class="hljs-comment">// store/modules/foo.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  namespaced: <span class="hljs-literal">true</span>,
  <span class="hljs-comment">// IMPORTANT: state must be a function so the module can be</span>
  <span class="hljs-comment">// instantiated multiple times</span>
  state: () =&gt; ({
    count: <span class="hljs-number">0</span>
  }),
  actions: {
    inc: ({ commit }) =&gt; commit(<span class="hljs-string">&apos;inc&apos;</span>)
  },
  mutations: {
    inc: state =&gt; state.count++
  }
}
</code></pre>
<p>We can use <code>store.registerModule</code> to lazy-register this module in a route component&apos;s <code>asyncData</code> hook:</p>
<pre><code class="lang-html">// inside a route component
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ fooCount }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// import the module here instead of in `store/index.js`</span>
<span class="hljs-keyword">import</span> fooStoreModule <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../store/modules/foo&apos;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  asyncData ({ store }) {
    store.registerModule(<span class="hljs-string">&apos;foo&apos;</span>, fooStoreModule)
    <span class="hljs-keyword">return</span> store.dispatch(<span class="hljs-string">&apos;foo/inc&apos;</span>)
  },

  <span class="hljs-comment">// IMPORTANT: avoid duplicate module registration on the client</span>
  <span class="hljs-comment">// when the route is visited multiple times.</span>
  destroyed () {
    <span class="hljs-keyword">this</span>.$store.unregisterModule(<span class="hljs-string">&apos;foo&apos;</span>)
  },

  computed: {
    fooCount () {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$store.state.foo.count
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>Because the module is now a dependency of the route component, it will be moved into the route component&apos;s async chunk by webpack.</p>
<hr>
<p>Phew, that was a lot of code! This is because universal data-fetching is probably the most complex problem in a server-rendered app and we are laying the groundwork for easier further development. Once the boilerplate is set up, authoring individual components will be actually quite pleasant.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="routing.html" class="navigation navigation-prev " aria-label="Previous page: Routing and Code-Splitting">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="hydration.html" class="navigation navigation-next " aria-label="Next page: Client Side Hydration">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Data Pre-fetching and State","level":"1.6","depth":1,"next":{"title":"Client Side Hydration","level":"1.7","depth":1,"path":"hydration.md","ref":"hydration.md","articles":[]},"previous":{"title":"Routing and Code-Splitting","level":"1.5","depth":1,"path":"routing.md","ref":"routing.md","articles":[]},"dir":"ltr"},"config":{"plugins":["edit-link","theme-vuejs@git+https://github.com/pearofducks/gitbook-plugin-theme-vuejs.git","-fontsettings","github"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"edit-link":{"label":"Edit This Page","base":"https://github.com/vuejs/vue-ssr-docs/edit/master/"},"github":{"url":"https://github.com/vuejs/vue-ssr-docs/"},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":false,"twitter":false,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-vuejs":{},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"en","links":{"sharing":{"facebook":false,"twitter":false}},"gitbook":"*"},"file":{"path":"data.md","mtime":"2017-08-24T05:24:43.000Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-08-24T05:42:05.628Z"},"basePath":".","book":{"language":"en"}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-edit-link/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    

    </body>
</html>

